# PRD — «Стена шифров» (Crypto Wall)

## 1. Overview

**Продукт:** «Стена шифров» — веб-приложение, связанное с экспозицией Музея криптографии.

**Коротко:**
Посетители создают зашифрованные сообщения, привязанные к историческим эпохам криптографии, а другие пользователи (офлайн в музее и онлайн) пытаются их расшифровать. Это цифровой интерактив, который может существовать как на экранах в музее, так и по открытой ссылке.

**Базовая концепция:**
- Сообщения привязаны к эпохам (цифровая, индустриальная, домашинная, протокриптография).
- При создании сообщения приложение автоматически выбирает тип шифра, соответствующий эпохе.
- Другие пользователи видят «стену» шифров и могут пытаться их взломать.

---

## 2. Цели продукта

### 2.1. Для музея

1. Увеличить вовлечённость посетителей через интерактив, связанный с основной темой — криптографией.
2. Связать разные залы/эпохи в единый цифровой опыт.
3. Получить прототип, который можно реально использовать в музее на планшетах/киосках и по ссылке.

### 2.2. Для пользователя

1. Простой сценарий «я — шифровальщик и криптоаналитик»:
   - придумать секрет → зашифровать → дать другим взломать;
   - попробовать взломать чужие сообщения.
2. Познакомиться с базовыми идеями шифрования:
   - шифр Цезаря;
   - простые подстановки;
   - современный «цифровой» шифр (упрощённый пример).
3. Получить «артефакт» — шифрованное сообщение и/или QR-код, который можно сохранить/поделиться.

### 2.3. Для хакатона / создателя

1. Показать продукт, идеально подходящий площадке (Музей криптографии).
2. Продемонстрировать связку:
   - продуманный UX;
   - аккуратный UI;
   - использование AI/LLM для разработки (vibe coding).
3. Заложить основу для возможного реального использования после мероприятия.

---

## 3. Пользовательские роли

1. **Посетитель / Игрок**
   - Создаёт шифрованные послания.
   - Просматривает стену сообщений.
   - Пытается расшифровать выбранное сообщение.

2. **Музей / Администратор** (вне рамок MVP, заложить в архитектуру)
   - Смотрит статистику использования.
   - Потенциально модерирует контент.

---

## 4. Область действия (Scope)

### 4.1. Входит в MVP

1. Веб-приложение на Next.js (App Router) с базовыми страницами:
   - Главная (выбор режима).
   - Создание сообщения.
   - Попытка дешифровки (случайное сообщение).
   - Просмотр «стены шифров» (лента карточек сообщений).
   - Просмотр конкретного сообщения по ID/ссылке.

2. Реализация 2–3 типов шифров:
   - Шифр Цезаря.
   - Подстановочный шифр (простая моноалфавитная замена).
   - «Цифровой» шифр (упрощённый пример, например base64 + пояснение, что это не настоящий криптостойкий шифр, а иллюстрация).

3. Привязка шифров к эпохам:
   - Протокриптография → Цезарь.
   - Домашинная/индустриальная → подстановки.
   - Цифровая → «современный» пример (base64/другое).

4. Хранение данных в Supabase:
   - Таблица сообщений.
   - Чтение/запись через Supabase SDK.

5. Базовый UI:
   - Дизайн на shadcn/ui + Tailwind (тёмная тема, неоновый крипто-стиль).
   - Адаптивность (мобильный, планшет, десктоп).

6. Деплой на Vercel:
   - Один продакшен-деплой.
   - Конфигурация через env-переменные.

### 4.2. Не входит в MVP (но желательно предусмотреть)

1. Полноценная система аккаунтов и авторизации.
2. Модерация сообщений через админку.
3. Продвинутая статистика (дашборды, графики).
4. Геймификация (очки, рейтинги, уровни).
5. Локализация на несколько языков.

---

## 5. Пользовательские сценарии

### 5.1. Сценарий: Создать зашифрованное послание

1. Пользователь открывает главную страницу.
2. Выбирает режим «Создать послание».
3. На форме создания пользователь:
   - вводит псевдоним (необязательно);
   - вводит текст послания (ограничение по длине, например до 280 символов);
   - выбирает эпоху (селект/кнопки).
4. Приложение:
   - выбирает тип шифра, соответствующий эпохе;
   - шифрует текст;
   - сохраняет запись в Supabase.
5. После успешного сохранения пользователь видит:
   - шифротекст;
   - краткое описание шифра;
   - ссылку на сообщение;
   - кнопку «Показать QR-код» (если реализуется);
   - кнопку «Поделиться» (копирование ссылки).

### 5.2. Сценарий: Взломать случайное сообщение

1. Пользователь выбирает режим «Взломать послание» на главной или отдельной странице.
2. Backend выбирает случайное сообщение из базы.
3. На экране:
   - шифротекст;
   - информация об эпохе;
   - подсказка о типе шифра и пример.
4. Пользователь:
   - вводит предполагаемый исходный текст либо ключ (в зависимости от шифра);
   - нажимает «Проверить».
5. Приложение:
   - проверяет ответ;
   - если верно → показывает анимацию успеха и оригинальный текст, краткую историю шифра;
   - если неверно → даёт подсказку (например, подсветка букв, намёк на сдвиг).

### 5.3. Сценарий: Просмотр «Стены шифров»

1. Пользователь открывает страницу «Стена шифров».
2. Приложение загружает последние N сообщений (например, 50).
3. Каждый элемент отображается как карточка:
   - псевдоним автора;
   - эпоха;
   - часть шифротекста;
   - сложность.
4. По клику на карточку пользователь попадает на страницу конкретного сообщения и может попытаться его расшифровать (сценарий 5.2, но для выбранного сообщения).

---

## 6. Функциональные требования (детализация)

### 6.1. Страницы

- `/`  
  - CTA-кнопки: «Создать послание», «Взломать послание», «Стена шифров».
  - Краткое объяснение, что это за штука.

- `/encrypt`  
  - Форма создания сообщения.
  - Валидация длины текста.
  - Валидация эпохи (обязательное поле).

- `/decrypt`  
  - Загружает случайное сообщение.
  - Показывает шифротекст, эпоху, подсказки.
  - Поле ввода ответа.
  - Результат проверки.

- `/wall`  
  - Список карточек сообщений.
  - Пагинация или lazy-load (при необходимости).

- `/message/[id]`  
  - Страница конкретного сообщения.
  - Поле ввода предполагаемого исходного текста.
  - Проверка ответа.

### 6.2. Шифры (минимальный набор)

1. **caesar**
   - Алфавит: русский, английский (либо один выбранный; важно явно зафиксировать).
   - Фиксированный или случайный сдвиг (например, сдвиг 3).
   - Для проверки:
     - либо сравнение совпадения введённого текста с исходным;
     - либо вычисление сдвига из ответа и проверка.

2. **substitution**
   - Перестановка алфавита.
   - Алгоритмическая генерация таблицы соответствий.
   - Для MVP можно хранить plaintext в базе и сравнивать напрямую.

3. **digital_demo (base64 или аналог)**
   - Кодирование текста.
   - На экране — пояснение, что это не настоящий криптостойкий шифр, а демонстрация.

---

## 7. Модель данных (Supabase)

### Таблица `messages`

- `id` — `uuid`, PK.
- `created_at` — `timestamptz`, default `now()`.
- `author_alias` — `text` (nullable).
- `epoch` — `text` (например: `'digital' | 'industrial' | 'home' | 'proto'`).
- `cipher_type` — `text` (например: `'caesar' | 'substitution' | 'digital_demo'`).
- `ciphertext` — `text`, обязательное.
- `plaintext` — `text`, опционально (для проверки; можно зашифровать ещё раз).
- `difficulty` — `int` (1–3), опционально.

### Таблица `attempts` (опционально для MVP)

- `id` — `uuid`.
- `created_at` — `timestamptz`.
- `message_id` — `uuid`, FK → `messages.id`.
- `is_success` — `boolean`.
- `guess_plaintext` — `text`.

---

## 8. Нефункциональные требования

1. **Performance**
   - Время загрузки главной страницы ≤ 2–3 секунд на средних мобильных сетях.
   - Размер бандла минимизировать (ленивая загрузка тяжёлых частей, если появятся).

2. **Доступность**
   - Высокий контраст текста и фона.
   - Удобные элементы UI для работы стоя/с планшета.

3. **Надёжность**
   - При ошибке Supabase:
     - отображать понятное сообщение;
     - давать возможность «поиграться» с локально сгенерированным шифром без сохранения.

4. **Безопасность**
   - Ограничение длины сообщений.
   - Базовый фильтр стоп-слов (если успеем).

---

## 9. Метрики (для дальнейшего развития)

- Количество созданных сообщений в день.
- Количество попыток расшифровки на одно сообщение.
- Среднее время сессии.
- Отношение «создал / расшифровал» на пользователя (если появится авторизация).

---

## 10. Открытые вопросы

1. Какой алфавит используем (только русский, только английский, оба)?
2. Нужна ли сразу поддержка нескольких языков интерфейса?
3. Нужен ли режим «только офлайн» (без сохранения в Supabase) для эксплуатационного режима?

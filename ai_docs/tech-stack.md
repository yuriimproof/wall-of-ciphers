# Tech Stack & Architecture — «Стена шифров»

## 1. Общий обзор

**Цель:** собрать продукт как современное fullstack-веб-приложение, максимально дружественное к разработке с помощью LLM (vibe coding) и простое для деплоя.

**Основные компоненты:**
- **Next.js (App Router, TypeScript)** — frontend + backend.
- **Supabase** — база данных Postgres + SDK.
- **shadcn/ui + Tailwind CSS** — UI-компоненты и стили.
- **Vercel** — хостинг и деплой.
- Опционально: **Coolify** — self-hosted альтернатива, но не в рамках хакатона.

---

## 2. Next.js

### 2.1. Версия и режим

- Next.js 14+ (App Router).
- TypeScript включён.
- Server Components по умолчанию.
- Использование Server Actions для операций с данными (create/get).

### 2.2. Структура приложения (предлагаемая)

- `app/`
  - `layout.tsx` — общий layout.
  - `page.tsx` — главная (выбор режимов).
  - `encrypt/`
    - `page.tsx` — страница создания сообщения.
  - `decrypt/`
    - `page.tsx` — страница дешифровки случайного сообщения.
  - `wall/`
    - `page.tsx` — «Стена шифров».
  - `message/[id]/`
    - `page.tsx` — конкретное сообщение.

### 2.3. Server Actions (примерный список)

- `createMessage(formData)`:
  - Валидация входных данных (zod).
  - Выбор шифра по эпохе.
  - Шифрование и запись в Supabase.

- `getRandomMessage()`:
  - Выбор случайного сообщения из таблицы `messages`.

- `getMessageById(id)`:
  - Получение конкретного сообщения.

- `getLatestMessages(limit)`:
  - Получение N последних сообщений.

**Важно:** Server Actions должны быть чистыми и максимально декларативными, чтобы их было легко генерировать/редактировать через LLM.

---

## 3. Supabase

### 3.1. Использование

- Managed Supabase проект.
- Использование:
  - Postgres в качестве основного хранилища.
  - Supabase JS SDK для запросов.
- На старте можно использовать только public anon-ключ с простыми RLS-правилами или вообще без RLS, если это допустимо.

### 3.2. Модель данных

#### Таблица `messages`

- `id: uuid` — PK.
- `created_at: timestamptz` — default `now()`.
- `author_alias: text` — nullable.
- `epoch: text` — `'digital' | 'industrial' | 'home' | 'proto'` (как минимум такие варианты).
- `cipher_type: text` — `'caesar' | 'substitution' | 'digital_demo'`.
- `ciphertext: text` — зашифрованное послание.
- `plaintext: text` — исходный текст (опционально, может быть зашифрован ещё раз).
- `difficulty: int` — 1–3, опционально.

#### Таблица `attempts` (опционально)

- `id: uuid`.
- `created_at: timestamptz`.
- `message_id: uuid` — FK на `messages`.
- `is_success: boolean`.
- `guess_plaintext: text`.

---

## 4. Шифрование (алгоритмы на уровне приложения)

Реализация шифров идёт в коде (в Next.js), не в базе.

### 4.1. Шифр Цезаря (caesar)

- Функция вида:
  - `encryptCaesar(text: string, shift: number): string`
  - `decryptCaesar(text: string, shift: number): string`
- Решение по алфавиту:
  - В MVP можно зафиксировать один язык (например, русский или английский) или поддержать оба.
- Для MVP можно хранить:
  - исходный текст;
  - значение сдвига;
  - саму функцию дешифровки на клиенте/сервере.

### 4.2. Подстановочный шифр (substitution)

- Генерация таблицы соответствий (map символ → символ).
- Функция:
  - `generateSubstitutionMap(alphabet: string): Record<string, string>`
  - `encryptSubstitution(text: string, map: Record<string, string>): string`
- Для проверки можно:
  - хранить plaintext и сравнивать;
  - опционально сохранять map.

### 4.3. «Цифровой» демонстрационный шифр (digital_demo)

- Для MVP можно использовать:
  - base64 (кодирование/декодирование);
  - либо другой простой метод (важно подчеркнуть, что это условный пример, а не криптостойкий алгоритм).
- Функции:
  - `encryptDigitalDemo(text: string): string`
  - `decryptDigitalDemo(text: string): string`

---

## 5. UI — shadcn/ui + Tailwind

### 5.1. Библиотеки

- `shadcn/ui` — набор компонентов.
- `Tailwind CSS` — утилитарная система стилей.
- `lucide-react` — иконки.
- Дополнительно:
  - `react-hook-form` + `zod` — формы + валидация;
  - `@radix-ui/*` — под капотом shadcn при необходимости.

### 5.2. Компоненты (минимальный набор)

Использовать стандартные компоненты shadcn:

- `Button`
- `Card`
- `Input`
- `Textarea`
- `Tabs` (если нужны режимы/переключатели)
- `Badge`
- `Tooltip`
- `Dialog` (для успешной дешифровки / QR-кода)
- `Toaster` (уведомления, ошибки)
- `Progress` (для визуализации процесса)

### 5.3. Визуальный стиль

#### Цветовая палитра (пример)

- Фон:
  - Основной: очень тёмный, почти чёрный (`#020617` / `#020817`).
- Акценты:
  - Зеленоватый «терминальный» (`#22c55e` / `#4ade80`).
  - Холодный голубой (`#38bdf8` / `#0ea5e9`).
- Дополнительные:
  - Тёплый бежевый/охристый для акцентов «исторических эпох» (имитация бумаги, старых документов).

#### Типографика

- Базовый шрифт: читабельный sans-serif.
- Для шифротекстов и кода:
  - моноширинный шрифт (например, JetBrains Mono / IBM Plex Mono / аналог).
- Заголовки:
  - немного крупнее, чем обычно, чтобы выглядеть «музейно» и «технологично».

#### Общие принципы

- Тёмная тема по умолчанию.
- Мягкие скругления (`rounded-2xl`).
- Лёгкие тени (`shadow-md`/`shadow-lg`) на карточках.
- Большие кликабельные зоны для кнопок (padding, min-height).

---

## 6. Анимации и интерактив

- Использовать `framer-motion` (по желанию) для:
  - появления карточек на стене (fade + translate);
  - анимации процесса шифрования (допустим, текст плавно заменяется на шифротекст);
  - анимации успешной дешифровки (scale/opacity/blur).

- Анимации должны быть короткими (200–400 мс), чтобы не мешать быстро нажимать.

---

## 7. Деплой и окружение

### 7.1. Vercel

- Git-репозиторий (GitHub/GitLab/Bitbucket).
- Автоматический деплой из основной ветки (например, `main`).

**Environment variables:**

- `NEXT_PUBLIC_SUPABASE_URL`
- `NEXT_PUBLIC_SUPABASE_ANON_KEY`
- (опционально) `SUPABASE_SERVICE_ROLE_KEY` — только в серверной части, если потребуется.

### 7.2. Конфигурация Next.js

- Включить `experimental: { serverActions: true }` при необходимости (зависит от версии).
- Настройка `output: 'standalone'` (если когда-нибудь понадобится self-hosted).

---

## 8. Дополнительные библиотеки

- `zod` — схемы данных и валидация.
- `react-hook-form` — формы.
- `framer-motion` — анимации.
- `qrcode.react` или аналог — генерация QR-кодов (если включаем эту фичу).
- ESLint + Prettier — базовая код-стилистика.

---

## 9. Принципы разработки (под vibe coding)

1. **Декларативность:**
   - Чётко описывать компоненты и функции, чтобы LLM мог легко генерировать/дополнять код.

2. **Маленькие чёткие куски:**
   - Маленькие компоненты UI.
   - Ясные хелперы для шифрования.

3. **Чёткие промпты для LLM:**
   - Описывать:
     - контекст (Next, Supabase, shadcn);
     - что именно требуется (например, form + zod + server action);
     - формат ответа (полный код файла или только фрагмент).

4. **Трассировка и логирование:**
   - Простейшие `console.log` на этапе прототипа.
   - Понятные сообщения об ошибках на UI.

